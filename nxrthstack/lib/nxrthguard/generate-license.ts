#!/usr/bin/env npx tsx
/**
 * NxrthGuard License Key Generator
 *
 * This script generates valid NxrthGuard+ license keys.
 * For production use, integrate this with your store's backend.
 *
 * Supports two formats:
 * - Legacy (4 segments): NXRG-XXXX-XXXX-XXXX (checksum-based)
 * - Signed (7 segments): NXRG-XXXX-XXXX-XXXX-XXXX-XXXX-XXXX (Ed25519-derived)
 *
 * Usage:
 *   npx tsx scripts/generate-license.ts [count]
 *   npx tsx scripts/generate-license.ts --signed 5
 *   npx tsx scripts/generate-license.ts --batch 10
 *
 * Examples:
 *   npx tsx scripts/generate-license.ts          # Generate 1 legacy key
 *   npx tsx scripts/generate-license.ts --signed # Generate 1 signed key
 *   npx tsx scripts/generate-license.ts --signed 5        # Generate 5 signed keys
 *   npx tsx scripts/generate-license.ts --batch 100 > keys.txt
 */

import * as crypto from 'crypto';

// License key character set (no ambiguous characters like 0, O, 1, I, L)
const LICENSE_CHARSET = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';

// Secret component for legacy checksum (must match Rust implementation)
// "NXRG" as u32 little-endian
const SECRET_COMPONENT = 0x4E585247;

/**
 * Ed25519 public key for license signing (hex encoded)
 * Generated by: npx tsx scripts/generate-keypair.ts
 */
const LICENSE_PUBLIC_KEY_HEX = 'c7c8dd7f8cddc1be6385a0f42f1d9025e8cb0eb4f7fd4838565065d55a3af394';

type LicenseTier = 'plus' | 'trial' | 'free';
type LicenseFormat = 'legacy' | 'signed';

/**
 * Calculate the checksum for a license payload
 * This must match the Rust implementation exactly
 */
function calculateChecksum(payload: string): string {
  const bytes = Buffer.from(payload, 'utf8');
  let sum = 0;

  // Simple hash with position weighting
  for (let i = 0; i < bytes.length; i++) {
    // Wrapping multiply and add (simulating u32 wrapping behavior)
    sum = (sum + (bytes[i] * (i + 1))) >>> 0;
    sum = (sum * 31) >>> 0;
  }

  // XOR with secret component
  sum = (sum ^ SECRET_COMPONENT) >>> 0;

  // Convert to 4-character string using license charset
  const chars = LICENSE_CHARSET.split('');
  let result = '';

  for (let i = 0; i < 4; i++) {
    const idx = sum % chars.length;
    result += chars[idx];
    sum = Math.floor(sum / chars.length);
  }

  return result;
}

/**
 * Generate a random string from the license charset
 */
function randomChars(length: number): string {
  let result = '';
  for (let i = 0; i < length; i++) {
    const idx = Math.floor(Math.random() * LICENSE_CHARSET.length);
    result += LICENSE_CHARSET[idx];
  }
  return result;
}

/**
 * Generate a valid NxrthGuard license key (legacy format)
 */
function generateLegacyLicenseKey(tier: LicenseTier = 'plus'): string {
  // First segment: tier indicator + 3 random chars
  const tierChar = tier === 'plus' ? 'P' : tier === 'trial' ? 'T' : 'F';
  const seg1 = tierChar + randomChars(3);

  // Second segment: 4 random chars (unique identifier)
  const seg2 = randomChars(4);

  // Calculate checksum from payload
  const payload = `${seg1}-${seg2}`;
  const checksum = calculateChecksum(payload);

  return `NXRG-${seg1}-${seg2}-${checksum}`;
}

/**
 * Encode bytes to our custom Base32 charset
 */
function encodeToBase32(bytes: Buffer): string {
  const chars = LICENSE_CHARSET.split('');
  let result = '';
  let buffer = 0;
  let bitsInBuffer = 0;

  for (const byte of bytes) {
    buffer = (buffer << 8) | byte;
    bitsInBuffer += 8;

    while (bitsInBuffer >= 5) {
      bitsInBuffer -= 5;
      const idx = (buffer >> bitsInBuffer) & 0x1f;
      result += chars[idx];
    }
  }

  // Handle remaining bits
  if (bitsInBuffer > 0) {
    const idx = (buffer << (5 - bitsInBuffer)) & 0x1f;
    result += chars[idx];
  }

  return result;
}

/**
 * Generate a signed license key using Ed25519-derived signature
 */
function generateSignedLicenseKey(tier: LicenseTier = 'plus'): string {
  // Check if we have a valid public key
  if (LICENSE_PUBLIC_KEY_HEX === '0000000000000000000000000000000000000000000000000000000000000000') {
    console.error('\nERROR: You must set LICENSE_PUBLIC_KEY_HEX first!');
    console.error('Run: npx tsx scripts/generate-keypair.ts');
    console.error('Then copy the public key hex value to this script.\n');
    process.exit(1);
  }

  // First segment: tier indicator + 3 random chars
  const tierChar = tier === 'plus' ? 'P' : tier === 'trial' ? 'T' : 'F';
  const seg1 = tierChar + randomChars(3);

  // Second segment: 4 random chars (unique identifier)
  const seg2 = randomChars(4);

  // Create the message to sign
  const message = `NXRG-${seg1}-${seg2}`;

  // Create signature: SHA256(public_key || message)[0:10]
  const publicKeyBytes = Buffer.from(LICENSE_PUBLIC_KEY_HEX, 'hex');
  const hash = crypto.createHash('sha256');
  hash.update(publicKeyBytes);
  hash.update(message);
  const sigBytes = hash.digest().slice(0, 10);

  // Encode signature to our Base32 charset (10 bytes = 16 chars)
  const sigEncoded = encodeToBase32(sigBytes);

  // Split signature into 4-char segments
  const sig1 = sigEncoded.slice(0, 4);
  const sig2 = sigEncoded.slice(4, 8);
  const sig3 = sigEncoded.slice(8, 12);
  const sig4 = sigEncoded.slice(12, 16);

  return `NXRG-${seg1}-${seg2}-${sig1}-${sig2}-${sig3}-${sig4}`;
}

/**
 * Generate a valid NxrthGuard license key
 */
function generateLicenseKey(tier: LicenseTier = 'plus', format: LicenseFormat = 'legacy'): string {
  if (format === 'signed') {
    return generateSignedLicenseKey(tier);
  }
  return generateLegacyLicenseKey(tier);
}

/**
 * Validate a license key (for testing)
 */
function validateLicenseKey(key: string): { valid: boolean; tier: LicenseTier | null; format: LicenseFormat | null; error?: string } {
  // Normalize
  const normalizedKey = key.trim().toUpperCase();

  // Check format
  const parts = normalizedKey.split('-');

  if (parts[0] !== 'NXRG') {
    return { valid: false, tier: null, format: null, error: 'Invalid prefix: expected NXRG' };
  }

  // Determine format based on segment count
  if (parts.length === 4) {
    return validateLegacyLicenseKey(parts);
  } else if (parts.length === 7) {
    return validateSignedLicenseKey(parts);
  } else {
    return { valid: false, tier: null, format: null, error: 'Invalid format: expected 4 or 7 segments' };
  }
}

function validateLegacyLicenseKey(parts: string[]): { valid: boolean; tier: LicenseTier | null; format: LicenseFormat | null; error?: string } {
  // Check segment lengths
  for (let i = 1; i < 4; i++) {
    if (parts[i].length !== 4) {
      return { valid: false, tier: null, format: 'legacy', error: `Segment ${i} has wrong length` };
    }
    // Check charset
    for (const char of parts[i]) {
      if (!LICENSE_CHARSET.includes(char)) {
        return { valid: false, tier: null, format: 'legacy', error: `Invalid character: ${char}` };
      }
    }
  }

  // Validate checksum
  const payload = `${parts[1]}-${parts[2]}`;
  const expectedChecksum = calculateChecksum(payload);
  if (parts[3] !== expectedChecksum) {
    return { valid: false, tier: null, format: 'legacy', error: 'Invalid checksum' };
  }

  // Parse tier
  const firstChar = parts[1][0];
  const tier: LicenseTier = firstChar === 'P' ? 'plus' : firstChar === 'T' ? 'trial' : 'free';

  return { valid: true, tier, format: 'legacy' };
}

function validateSignedLicenseKey(parts: string[]): { valid: boolean; tier: LicenseTier | null; format: LicenseFormat | null; error?: string } {
  // Check segment lengths
  for (let i = 1; i < 7; i++) {
    if (parts[i].length !== 4) {
      return { valid: false, tier: null, format: 'signed', error: `Segment ${i} has wrong length` };
    }
    // Check charset
    for (const char of parts[i]) {
      if (!LICENSE_CHARSET.includes(char)) {
        return { valid: false, tier: null, format: 'signed', error: `Invalid character: ${char}` };
      }
    }
  }

  // Check if we have a valid public key
  if (LICENSE_PUBLIC_KEY_HEX === '0000000000000000000000000000000000000000000000000000000000000000') {
    return { valid: false, tier: null, format: 'signed', error: 'Public key not configured' };
  }

  // Recreate the signature and compare
  const message = `${parts[0]}-${parts[1]}-${parts[2]}`;
  const publicKeyBytes = Buffer.from(LICENSE_PUBLIC_KEY_HEX, 'hex');
  const hash = crypto.createHash('sha256');
  hash.update(publicKeyBytes);
  hash.update(message);
  const expectedSigBytes = hash.digest().slice(0, 10);
  const expectedSig = encodeToBase32(expectedSigBytes);

  const actualSig = parts[3] + parts[4] + parts[5] + parts[6];
  if (actualSig !== expectedSig) {
    return { valid: false, tier: null, format: 'signed', error: 'Invalid signature' };
  }

  // Parse tier
  const firstChar = parts[1][0];
  const tier: LicenseTier = firstChar === 'P' ? 'plus' : firstChar === 'T' ? 'trial' : 'free';

  return { valid: true, tier, format: 'signed' };
}

// CLI interface
function main() {
  const args = process.argv.slice(2);

  // Check for help flag
  if (args.includes('--help') || args.includes('-h')) {
    console.log(`
NxrthGuard License Key Generator

Usage:
  npx tsx scripts/generate-license.ts [options] [count]

Options:
  --help, -h     Show this help message
  --batch, -b    Generate multiple keys (same as count argument)
  --validate     Validate a license key instead of generating
  --signed       Generate signed keys (requires public key setup)
  --trial        Generate a 7-day trial key (Plus features, expires)
  --free         Generate a free tier key (default is Plus)

License Formats:
  Legacy (4 segments): NXRG-XXXX-XXXX-XXXX (checksum-based)
  Signed (7 segments): NXRG-XXXX-XXXX-XXXX-XXXX-XXXX-XXXX (Ed25519-derived)

License Tiers:
  Plus (P):  Full Plus license, no expiration
  Trial (T): 7-day trial of Plus features, one per machine
  Free (F):  Free tier key (for testing)

Setup for signed keys:
  1. Run: npx tsx scripts/generate-keypair.ts
  2. Copy the public key hex to LICENSE_PUBLIC_KEY_HEX in this file
  3. Copy the public key Rust code to core/src/license/key.rs
  4. Keep the private key secret on your server

Examples:
  npx tsx scripts/generate-license.ts              # Generate 1 legacy Plus key
  npx tsx scripts/generate-license.ts --signed     # Generate 1 signed Plus key
  npx tsx scripts/generate-license.ts --signed 5   # Generate 5 signed Plus keys
  npx tsx scripts/generate-license.ts --trial      # Generate 1 legacy Trial key
  npx tsx scripts/generate-license.ts --signed --trial 10  # Generate 10 signed Trial keys
  npx tsx scripts/generate-license.ts --validate NXRG-PXXX-XXXX-XXXX
`);
    process.exit(0);
  }

  // Check for validate mode
  const validateIdx = args.indexOf('--validate');
  if (validateIdx !== -1) {
    const keyToValidate = args[validateIdx + 1];
    if (!keyToValidate) {
      console.error('Error: Please provide a license key to validate');
      process.exit(1);
    }

    const result = validateLicenseKey(keyToValidate);
    if (result.valid) {
      console.log(`\u2713 Valid ${result.format?.toUpperCase()} ${result.tier?.toUpperCase()} license key`);
    } else {
      console.log(`\u2717 Invalid: ${result.error}`);
    }
    process.exit(result.valid ? 0 : 1);
  }

  // Determine format
  const format: LicenseFormat = args.includes('--signed') ? 'signed' : 'legacy';

  // Determine tier
  let tier: LicenseTier = 'plus';
  if (args.includes('--free')) {
    tier = 'free';
  } else if (args.includes('--trial')) {
    tier = 'trial';
  }

  // Determine count
  let count = 1;
  const batchIdx = args.findIndex(a => a === '--batch' || a === '-b');
  if (batchIdx !== -1 && args[batchIdx + 1]) {
    count = parseInt(args[batchIdx + 1], 10);
  } else {
    // Check for numeric argument
    const numArg = args.find(a => /^\d+$/.test(a));
    if (numArg) {
      count = parseInt(numArg, 10);
    }
  }

  if (isNaN(count) || count < 1) {
    console.error('Error: Invalid count');
    process.exit(1);
  }

  // Generate keys
  const formatName = format === 'signed' ? 'SIGNED' : 'LEGACY';
  console.log(`\nGenerating ${count} NxrthGuard ${formatName} ${tier.toUpperCase()} license key(s):\n`);
  console.log('='.repeat(60));

  for (let i = 0; i < count; i++) {
    const key = generateLicenseKey(tier, format);
    console.log(key);

    // Validate each generated key (sanity check)
    const validation = validateLicenseKey(key);
    if (!validation.valid) {
      console.error(`  WARNING: Generated key failed validation: ${validation.error}`);
    }
  }

  console.log('='.repeat(60));
  console.log(`\nGenerated ${count} ${formatName.toLowerCase()} key(s). Copy a key and paste it in NxrthGuard Settings to activate.\n`);

  if (format === 'signed') {
    console.log('Signed keys provide cryptographic verification and are recommended for production.');
  }

  if (tier === 'plus') {
    console.log('Plus licenses have no expiration and work on one machine.');
  } else if (tier === 'trial') {
    console.log('Trial licenses expire after 7 days and can only be activated once per machine.');
  }
  console.log('To deactivate, click "Deactivate License" in Settings.');
}

main();
